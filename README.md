
![2](https://user-images.githubusercontent.com/62537935/190548170-fe3c9a73-4161-4d82-92c1-a2baf561d755.png)

# 0827

JPA의 모든 데이터 변경은 트랜잭션 안에서 실행<br>

도메인 설정시<br>
DB에 테이블 이름과 domain이 다르면 @Table 어노테이션에 명시<br>
Table 컬럼명이 다르면 @Column(name = "test")으로 명시

영속성 컨텍스트 : 엔티티를 영구 저장하는 환경<br>
1차 캐시 : 동일한 트랜잭션 안에서 같은 쿼리를 사용했을때 DB에 쿼리가 안날라감 (성능상 중요하진 않음)
플러시 : 영속성 컨텍스트의 변경내용을 즉시 DB에 반영<br>

# 0828
엔티티 매핑<br>
객체와 테이블 매핑 : @Entity, @Table<br>
필드와 컬럼 매핑 : @Column<br>
기본키 매핑 : @Id<br>
연관관계 매핑 : @ManyToOne, @JoinColumn<br>

@Transient : DB와 상관없는 컬럼

# 0901
기본키 매핑<br>
@Id : 직접 할당<br>

@GeneratedValue : 자동 생성<br>
IDENTITY 전략 : 기본키 생성을 DB에 위임<br>
SEQUENCE 전략 : 주로 오라클에서 사용

# 0905
연관관계 매핑 기초

# 0906
관례상 컬렉션이있으면 초기화를 해둔다. nullpoint 뜨지않게<br>

양방향 매핑 규칙<br>
1. 객체의 두 관계중 하나를 연관관계의 주인으로 지정
2. 연관관계의 주인만이 외래키를 관리(등록,수정)
3. 주인이 아니면 read만 가능
4. 주인은 mappedBy 속성 사용 안함
5. 주인이 아니면 mappedBy 속성으로 주인 지정

<br>
그럼 누구를 주인으로 할까 => 외래키가 있는 곳을 주인으로

# 0913
다양한 연관관계 매핑

# 0914
**_일대다 단방향_**<br>
일대다 단방향은 일대다(1:N)에서 1이 연관관계의 주인<br>
테이블 일대다 관계는 항상 다 쪽에 외래 키가 있음<br>
객체와 테이블의 차이 떄문에 반대편 테이블의 외래 키를 관리하는 특이한 구조<br>
@JoinColumn을 꼭 사용해야함 , 사용하지 않으면 조인 테이블 방식을 사용함<br>

**_단점_**<br>

엔티티가 관리하는 외래 키가 다른 테이블에 있음<br>
연관관계 관리를 위해 추가로 업데이트 sql 실행<br>
일대다 단방향 보다는 다대일 양방향이 더 좋음<br>

**_일대일_**<br>
일대일 관계는 그 반대도 일대일<br>
주 테이블이나 대상 테이블 중에 외래 키 선택 가능<br>
외래 키에 DB 유니크 제약조건 추가<br>
다대일 양방향 매핑처럼 외래키가 있는 곳이 연관관계 주인, 반대편은 mappedBy 적용<br>

**_주 테이블에 외래키 (주로 access하는 테이블)_**<br>
주 객체가 대상 객체의 참조를 가지는것 처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음<br>
JPA 매핑이 편리함<br>
장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능<br>
단점 : 값이 없으면 외래키에 null 허용<br>

**_대상 테이블에 외래키_**<br>
대상 테이블에 외래키가 존재
장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지<br>
단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

**_다대다_**<br>
다대다 매핑의 한계<br>
편리해 보이지만 실무에서 사용안함<br>
연결 테이블이 단순히 연결만 하고 끝나지 않음<br>
주문시간, 수량 같은 데이터가 들어올 수 있음<br>

**_다대다 한계 극복_**<br>
연결 테이블용 엔티티 추가(연결 테이블을 Entity로 승격)<br>
@ManyToMany를 => @OneToMany, @ManyToOne 로 풀어내야함

# 0915
**_상속관계 매핑_**

# 0916
**_프록시_**<br>
Member안에 Team이 있는 상황에 나는 Member만 조회하고 싶을때 항상 Team을 같이 가져오면 낭비가 발생된다 낭비를 방지 위해 프록시라는 개념으로 해결한다.<br>
Proxy 사전 의미 : 대리(행위)나 대리권, 대리 투표, 대리인 등을 뜻한다 => 뭔가 중계 기능을 하는것<br>

**_기초_**
1. em.find() : 데이터베이스를 통해 실제 엔티티 객체 조회
2. em.getReference() : **데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회** DB에 쿼리를 날리지 않아도 조회가됨 
![image](https://user-images.githubusercontent.com/62537935/190550564-f3b975ff-9113-42e7-adb5-cd4574b83269.png)

**_특징_**
1. 실제 클래스를 상속 받아서 만듦
2. 실제 클래스와 겉 모양이 같다
3. 사용하는 입장에서 진짜 객체인지 프록시인지 구분하지 않고 사용
4. 프록시 객체는 실제 객체의 참조(target)를 보관
5. **프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출**

**_특징2_**
1. 프록시 객체는 처음 사용할 때 한번만 초기화
2. 프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 바뀌는 것이 아니고 초기화 할 때 프록시 객체를 통해서 실제 엔티티에 접근하는 거임
3. 프록시 객체는 원본 엔티티를 상속 받음, 타입체크 주의 instance of 사용
4. 영속성 컨텍스트에 찾는 엔티티가 이미 있으면(1차 캐시에 있는경우) em.getReference()를 호출해도 실제 엔티티를 반환<br>
반대로 프록시를 먼저 조회하고 엔티티를 찾아도 프록시가 조회됨 == 비교를 원활하게 하기 위해
5. 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화 하면 문제가 발생됨

**_즉시로딩, 지연로딩_**
1. 지연로딩 : FetchType.LAZY 비지니스 로직상 Member만 조회하는 경우가 많을 때
2. 즉시로딩 : FetchType.EAGER 비지니스 로직상 Member와 Team을 조회하는 경우가 많을 때 (이론적으로는 즉시로딩이지만 다 지연로딩으로 하면 좋음)

**_주의_**
1. 가급적 지연로딩만 사용 (실무에서는)
2. 즉시 로딩을 사용하면 예상치 못한 SQL이 발생
3. 즉시 로딩은 JPQL에서 N + 1 문제를 일으킨다.
4. @ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정
5. @OneToMany, @ManyToMany는 기본이 지연 로딩

**_실무_**
1. 모든 연관관계는 지연 로딩을 사용해라
2. 실무에서 즉시 로딩 사용하지 마라
3. JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라

**_영속성 전이(CASECADE)와 고아 객체_**<br>
고아 객체 : 부모 엔티티와 연관관계가 끊어진 자식 객체<br>
참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능

# 0919
**_임베디드 타입과 테이블 매핑_**<br>
임베디드 타입은 엔티티의 값일 뿐이다<br>
임베디드 타입을 사용하기 전과 후에 **매핑하는 테이블은 같다**<br>
@AttributeOverride : 속성 재정의 => 한 엔티티에서 같은 값 타입을 사용할 경우<br>
값 타입 공유 참조 : 임베디드 값 타입을 여러 엔티티에서 공유하면 위험함 사이트 이펙트 발생
![image](https://user-images.githubusercontent.com/62537935/190937834-549a4493-21a5-4374-b6a4-d33b8ad32b90.png)
둘다 바뀜<br>

**_값 타입의 비교_**<br>
동일성(identity) 비교 : 인스턴스의 참조 값을 비교 , == 사용 <br>
동등성(equivalence) 비교 : 인스턴스의 값을 비교, equals() 사용 <br>
값 타입은 a.equals(b)를 사용하여 동등성 비교<br>
값 타입의 equals() 메소드를 적정하게 재정의 (주로 모든 필드 사용)

**_값 타입 컬렉션_**<br>
캆 타입을 하나 이상 저장할 때 사용<br>
@ElementCollection, @CollectionTable 사용<br>
데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.<br>
컬렉션을 저장하기 위한 별도의 테이블이 필요함<br>

**_값 타입 컬렉션의 제약사항_**<br>
값 타입은 엔티티와 다르게 식별자 개념이 없음<br>
값은 변경하면 추적이 어려움<br>

값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장함<br>
값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야함 : null 입력x, 중복저장 x<br>

**_값 타입 컬렉션 대안_**<br>
실무에서는 상황에 따라 값 타입 컬렉션 대신 일대다 관계 사용<br>

# 0920
**_페치 조인 (fetch join)_**<br>
SQL 조인 종류 아님<br>
연관된 엔티티나 컬렉션을 SQL을 한번에 조회하는 기능<br>
**_엔티티 페치 조인_**<br>
회원을 조회하면서 연관된 팀도 조회<br>
```sql
select m from Member m join fetch m.team
```
페치 조인의 한계
페치 조인 대상에는 별칭 안됨
둘 이상의 컬렉션은 페치 조인 안됨
컬렉션을 페치 조인하면 페이징 사용못함
