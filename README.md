# 0827

JPA의 모든 데이터 변경은 트랜잭션 안에서 실행<br>

도메인 설정시<br>
DB에 테이블 이름과 domain이 다르면 @Table 어노테이션에 명시<br>
Table 컬럼명이 다르면 @Column(name = "test")으로 명시

영속성 컨텍스트 : 엔티티를 영구 저장하는 환경<br>
1차 캐시 : 동일한 트랜잭션 안에서 같은 쿼리를 사용했을때 DB에 쿼리가 안날라감 (성능상 중요하진 않음)
플러시 : 영속성 컨텍스트의 변경내용을 즉시 DB에 반영<br>

# 0828
엔티티 매핑<br>
객체와 테이블 매핑 : @Entity, @Table<br>
필드와 컬럼 매핑 : @Column<br>
기본키 매핑 : @Id<br>
연관관계 매핑 : @ManyToOne, @JoinColumn<br>

@Transient : DB와 상관없는 컬럼

# 0901
기본키 매핑<br>
@Id : 직접 할당<br>

@GeneratedValue : 자동 생성<br>
IDENTITY 전략 : 기본키 생성을 DB에 위임<br>
SEQUENCE 전략 : 주로 오라클에서 사용

# 0905
연관관계 매핑 기초

# 0906
관례상 컬렉션이있으면 초기화를 해둔다. nullpoint 뜨지않게<br>

양방향 매핑 규칙<br>
1. 객체의 두 관계중 하나를 연관관계의 주인으로 지정
2. 연관관계의 주인만이 외래키를 관리(등록,수정)
3. 주인이 아니면 read만 가능
4. 주인은 mappedBy 속성 사용 안함
5. 주인이 아니면 mappedBy 속성으로 주인 지정

<br>
그럼 누구를 주인으로 할까 => 외래키가 있는 곳을 주인으로

# 0913
다양한 연관관계 매핑

# 0914
## 일대다 단방향<br>
일대다 단방향은 일대다(1:N)에서 1이 연관관계의 주인<br>
테이블 일대다 관계는 항상 다 쪽에 외래 키가 있음<br>
객체와 테이블의 차이 떄문에 반대편 테이블의 외래 키를 관리하는 특이한 구조<br>
@JoinColumn을 꼭 사용해야함 , 사용하지 않으면 조인 테이블 방식을 사용함<br>
### 단점<br>
엔티티가 관리하는 외래 키가 다른 테이블에 있음<br>
연관관계 관리를 위해 추가로 업데이트 sql 실행<br>
일대다 단방향 보다는 다대일 양방향이 더 좋음<br>

## 일대일<br>
일대일 관계는 그 반대도 일대일<br>
주 테이블이나 대상 테이블 중에 외래 키 선택 가능<br>
외래 키에 DB 유니크 제약조건 추가<br>
다대일 양방향 매핑처럼 외래키가 있는 곳이 연관관계 주인, 반대편은 mappedBy 적용<br>

주 테이블에 외래키 (주로 access하는 테이블)<br>
주 객체가 대상 객체의 참조를 가지는것 처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음<br>
JPA 매핑이 편리함<br>
장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능<br>
단점 : 값이 없으면 외래키에 null 허용<br>

대상 테이블에 외래키<br>
대상 테이블에 외래키가 존재
장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지<br>
단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

## 다대다<br>
다대다 매핑의 한계<br>
편리해 보이지만 실무에서 사용안함<br>
연결 테이블이 단순히 연결만 하고 끝나지 않음<br>
주문시간, 수량 같은 데이터가 들어올 수 있음<br>

## 다대다 한계 극복<br>
연결 테이블용 엔티티 추가(연결 테이블을 Entity로 승격)<br>
@ManyToMany를 => @OneToMany, @ManyToOne 로 풀어내야함
